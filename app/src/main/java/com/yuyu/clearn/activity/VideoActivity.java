package com.yuyu.clearn.activity;import android.content.Context;import android.media.MediaPlayer;import android.net.Uri;import android.os.Bundle;import android.os.Environment;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.KeyEvent;import android.view.View;import com.google.vr.sdk.widgets.video.VrVideoView;import com.naver.speech.clientapi.SpeechRecognitionResult;import com.yuyu.clearn.R;import com.yuyu.clearn.api.realm.UserVO;import com.yuyu.clearn.api.reognizer.AudioWriterPCM;import com.yuyu.clearn.api.reognizer.NaverRecognizer;import com.yuyu.clearn.api.retrofit.Member;import com.yuyu.clearn.api.retrofit.RestInterface;import com.yuyu.clearn.custom.Constant;import java.io.IOException;import java.lang.ref.WeakReference;import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;import butterknife.BindView;import butterknife.ButterKnife;import io.realm.Realm;import io.realm.RealmConfiguration;import rx.Observable;import rx.Subscriber;public class VideoActivity extends AppCompatActivity {    @BindView(R.id.video_view)    VrVideoView video_view;    private final String TAG = VideoActivity.class.getSimpleName();    private final String CLIENT_ID = "hgjHh11TeYg649dN5zT1";    private final String TEST = "Test", SPEECH_TEST = "/NaverSpeech" + TEST, DATE_TYPE = "yyyy-MM-dd:HH-mm-ss";    private final String VIDEO = "VIDEO", NUMBER = "NUMBER", FINISH = "FINISH", SAVE = "SAVE", RESULT = "RESULT", REALM_NAME = "CLearn.db";    private final String NONE = "", DESTROY = "종료", PLAY = "재생", STOP = "정지", NEXT = "앞으로", PREV = "뒤로", RESET = "처음으로";    private final String STUDY = "수업";    private final int SEND_TIME = 2000, CONTROL_TIME = 20000, MAIN_SCREEN = 0, VIDEO_SCREEN = 1;    private Realm realm;    private UserVO userVO;    private Thread thread;    private Context context;    VrVideoView.Options options;    private MediaPlayer mediaPlayer;    private AudioWriterPCM audioWriterPCM;    private NaverRecognizer naverRecognizer;    private int status;    private long v_ctime, load_time;    private boolean isPause;    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_video);        ButterKnife.bind(this);        context = this;        options = new VrVideoView.Options();        options.inputFormat = VrVideoView.Options.FORMAT_DEFAULT;        options.inputType = VrVideoView.Options.TYPE_MONO;        naverRecognizer = new NaverRecognizer(context, new RecognitionHandler(this), CLIENT_ID);        // 동영상 시작 시 풀 스크린 모드로 진행        video_view.setDisplayMode(VrVideoView.DisplayMode.FULLSCREEN_STEREO);        video_view.fullScreenDialog.setCancelable(false);        video_view.fullScreenDialog.setOnKeyListener((dialogInterface, i, keyEvent) -> {            // 뒤로가기 버튼이 터치 되었을 경우(컨트롤러 포함) 음성 인식 이벤트를 2초간 받음            if (keyEvent.getAction() == KeyEvent.ACTION_UP && !naverRecognizer.getSpeechRecognizer().isRunning()) {                naverRecognizer.recognize();                mediaPlayerInit(R.raw.start);                new Handler() {                    @Override                    public void handleMessage(Message msg) {                        naverRecognizer.getSpeechRecognizer().stop();                    }                }.sendEmptyMessageDelayed(0, SEND_TIME);            }            return false;        });        mainScreenViewFirst();    }    @Override    public void onResume() {        super.onResume();        getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION ^ View.SYSTEM_UI_FLAG_FULLSCREEN ^ View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);        naverRecognizer.getSpeechRecognizer().initialize();        video_view.resumeRendering();        video_view.seekTo(v_ctime);        if (isPause) {            video_view.pauseVideo();        } else {            video_view.playVideo();        }    }    @Override    public void onPause() {        super.onPause();        naverRecognizer.getSpeechRecognizer().release();        v_ctime = video_view.getCurrentPosition();        video_view.pauseRendering();    }    private void mainScreenViewFirst() {        Realm.init(context);        Observable.just(realm = Realm.getInstance(new RealmConfiguration.Builder()                .name(REALM_NAME)                .build()))                .subscribe(realm1 -> {                    realm1.beginTransaction();                    Observable.just(userVO = realm1.createObject(UserVO.class, getSharedPreferences(VIDEO, MODE_PRIVATE).getInt(NUMBER, 0)))                            .doOnUnsubscribe(() -> {                                createThread();                                mainScreenView();                            })                            .subscribe(userVO -> {                                userVO.setV_num(getIntent().getIntExtra(Constant.V_NUM, -1));                                userVO.setP_token(getIntent().getStringExtra(Constant.P_TOKEN));                                userVO.setStart_time(new SimpleDateFormat(DATE_TYPE).format(new Date()));                            });                });    }    public void mainScreenView() {        status = MAIN_SCREEN;        try {            video_view.loadVideo(Uri.parse(RestInterface.BASE + RestInterface.RESOURCES + RestInterface.VIDEO + RestInterface.MAIN_SCREEN), options);        } catch (IOException e) {            Log.e(TAG, String.valueOf(e));        }    }    // PostVideo 인터페이스를 사용해 이전 로그인 액티비티에서 전달받은 값    // v_num과 p_token을 서버에 request 이후 response 받은 여러 정보들을 사용    public void videoScreenViewFirst() {        RestInterface.getRestClient()                .create(RestInterface.PostVideo.class)                .video(VIDEO.toLowerCase(), getIntent().getIntExtra(Constant.V_NUM, -1), getIntent().getStringExtra(Constant.P_TOKEN))                .subscribe(new Subscriber<Member>() {                    @Override                    public void onCompleted() {                    }                    @Override                    public void onError(Throwable e) {                        Log.e(TAG, String.valueOf(e));                    }                    @Override                    public void onNext(Member member) {                        Observable.just(member.getCt_file())                                .map(text -> Uri.parse(RestInterface.BASE + RestInterface.RESOURCES + RestInterface.VIDEO + member.getCt_file()))                                .doOnUnsubscribe(() -> video_view.seekTo(v_ctime = member.getV_ctime()))                                .subscribe(uri -> videoScreenView(uri));                    }                });    }    public void videoScreenView(Uri uri) {        status = VIDEO_SCREEN;        load_time = System.currentTimeMillis();        try {            video_view.loadVideo(uri, options);        } catch (IOException e) {            Log.e(TAG, String.valueOf(e));        }    }    // 미디어 플레이어 혹은 비디오 플레이어가 종료되면 실행되는 인터페이스인    // OnCompletionListener가 VrVideoView에 없는 관계로 직접 구현함    // Thread를 돌려서 해당 동영상이 종료되면(총 재생 시간보다 현재 재생 시간이 많거나 같을 경우)    // PostFinish 인터페이스를 사용해 이전 로그인 액티비티에서 전달받은 값 v_num을 서버에 request    // 이후 해당 v_num의 v_finish의 값을 N에서 Y로 update    public void createThread() {        Runnable runnable = () -> {            while (!thread.isInterrupted()) {                v_ctime = video_view.getCurrentPosition();                if (v_ctime >= video_view.getDuration() && load_time + 2000 <= System.currentTimeMillis()) {                    switch (status) {                        case MAIN_SCREEN:                            video_view.seekTo(v_ctime = 0);                            break;                        case VIDEO_SCREEN:                            RestInterface.getRestClient()                                    .create(RestInterface.PostFinish.class)                                    .finish(FINISH.toLowerCase(), getIntent().getIntExtra(Constant.V_NUM, -1))                                    .subscribe(new Subscriber<Void>() {                                        @Override                                        public void onCompleted() {                                        }                                        @Override                                        public void onError(Throwable e) {                                            Log.e(TAG, String.valueOf(e));                                        }                                        @Override                                        public void onNext(Void aVoid) {                                            mainScreenView();                                        }                                    });                            break;                        default:                            break;                    }                }            }        };        thread = new Thread(runnable);        thread.start();    }    // 음성 인식 이벤트 과정    public void handleMessage(Message msg) {        switch (msg.what) {            case R.id.clientReady:                audioWriterPCM = new AudioWriterPCM(                        Environment.getExternalStorageDirectory().getAbsolutePath() + SPEECH_TEST);                audioWriterPCM.open(TEST);                break;            case R.id.audioRecording:                audioWriterPCM.write((short[]) msg.obj);                break;            case R.id.finalResult:                recognizerResult(msg);                break;            case R.id.recognitionError:                if (audioWriterPCM != null) {                    audioWriterPCM.close();                }                break;            case R.id.clientInactive:                if (audioWriterPCM != null) {                    audioWriterPCM.close();                }                break;            default:                break;        }    }    public void recognizerResult(Message msg) {        SpeechRecognitionResult speechRecognitionResult = (SpeechRecognitionResult) msg.obj;        List<String> results = speechRecognitionResult.getResults();        boolean isSpeechEvent = false;        String speechEvent = NONE;        // 음성 인식 이벤트 처리        for (String result : results) {            switch (status) {                case MAIN_SCREEN:                    if (result.contains(DESTROY)) {                        speechEvent = DESTROY;                        videoDestroy(realm, userVO);                    } else if (result.contains(STUDY)) {                        speechEvent = STUDY;                        videoScreenViewFirst();                    }                    break;                case VIDEO_SCREEN:                    if (result.contains(DESTROY)) {                        speechEvent = DESTROY;                        videoSave();                    } else if (result.contains(PLAY)) {                        speechEvent = PLAY;                        isPause = true;                        video_view.playVideo();                    } else if (result.contains(STOP)) {                        speechEvent = STOP;                        isPause = false;                        video_view.pauseVideo();                    } else if (result.contains(NEXT)) {                        speechEvent = NEXT;                        video_view.seekTo(v_ctime += CONTROL_TIME);                    } else if (result.contains(PREV)) {                        speechEvent = PREV;                        video_view.seekTo(v_ctime -= CONTROL_TIME);                    } else if (result.contains(RESET)) {                        speechEvent = RESET;                        video_view.seekTo(v_ctime = 0);                    }                    break;                default:                    break;            }            if (!speechEvent.equals(NONE)) {                isSpeechEvent = true;                break;            }        }        if (!isSpeechEvent) {            mediaPlayerInit(R.raw.re);        }    }    // Realm DB에 데이터를 저장하고    // 현재 재생 시간을 PostSave 인터페이스를 사용해 이전 로그인 액티비티에서 전달받은 값 v_num과    // 현재 재생 시간인 v_ctime, Realm DB의 값 realm1을 서버에 request 이후 해당 v_num에 v_ctime을 update    public void videoSave() {        getSharedPreferences(VIDEO, MODE_PRIVATE).edit().putInt(NUMBER, getSharedPreferences(VIDEO, MODE_PRIVATE).getInt(NUMBER, 0) + 1).apply();        RestInterface.getRestClient()                .create(RestInterface.PostSave.class)                .save(SAVE.toLowerCase(), getIntent().getIntExtra(Constant.V_NUM, -1), v_ctime)                .subscribe(new Subscriber<Void>() {                    @Override                    public void onCompleted() {                    }                    @Override                    public void onError(Throwable e) {                        Log.e(TAG, String.valueOf(e));                    }                    @Override                    public void onNext(Void aVoid) {                        mainScreenView();                    }                });    }    // OnCompletionListener 역할을 대신 수행하는 Thread 및 어플을 종료    public void videoDestroy(Realm realm, UserVO userVO) {        Observable.just(realm)                .map(realm1 -> {                    userVO.setEnd_time(new SimpleDateFormat(DATE_TYPE).format(new Date()));                    realm.insert(userVO);                    realm.commitTransaction();                    return realm1.where(UserVO.class).findAll().toString();                })                .subscribe(realm1 -> {                    RestInterface.getRestClient()                            .create(RestInterface.PostResult.class)                            .result(RESULT.toLowerCase(), getIntent().getStringExtra(Constant.P_TOKEN), realm1)                            .doOnUnsubscribe(() -> {                                mediaPlayerInit(R.raw.destroy);                                thread.interrupt();                                video_view.fullScreenDialog.dismiss();                                video_view.pauseRendering();                                video_view.shutdown();                                finish();                            })                            .subscribe(new Subscriber<Void>() {                                @Override                                public void onCompleted() {                                }                                @Override                                public void onError(Throwable e) {                                    Log.e(TAG, String.valueOf(e));                                }                                @Override                                public void onNext(Void aVoid) {                                    mainScreenView();                                }                            });                });    }    public void mediaPlayerInit(int resId) {        if (mediaPlayer != null) {            mediaPlayer.stop();            mediaPlayer.release();        }        mediaPlayer = MediaPlayer.create(context, resId);        mediaPlayer.setOnPreparedListener(MediaPlayer::start);    }    private static class RecognitionHandler extends Handler {        private final WeakReference<VideoActivity> weakReference;        RecognitionHandler(VideoActivity activity) {            weakReference = new WeakReference<>(activity);        }        @Override        public void handleMessage(Message msg) {            VideoActivity activity = weakReference.get();            if (activity != null) {                activity.handleMessage(msg);            }        }    }}