package com.yuyu.clearn.activity;import android.content.Context;import android.media.MediaPlayer;import android.net.Uri;import android.os.Bundle;import android.os.Environment;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.KeyEvent;import android.view.View;import com.google.vr.sdk.widgets.video.VrVideoView;import com.naver.speech.clientapi.SpeechRecognitionResult;import com.yuyu.clearn.R;import com.yuyu.clearn.api.realm.User;import com.yuyu.clearn.api.reognizer.AudioWriterPCM;import com.yuyu.clearn.api.reognizer.NaverRecognizer;import com.yuyu.clearn.api.retrofit.Member;import com.yuyu.clearn.api.retrofit.RestInterface;import com.yuyu.clearn.view.Constant;import java.io.IOException;import java.lang.ref.WeakReference;import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;import butterknife.BindView;import butterknife.ButterKnife;import io.realm.Realm;import io.realm.RealmConfiguration;import rx.Observable;import rx.Subscriber;public class VideoActivity extends AppCompatActivity {    @BindView(R.id.video_view)    VrVideoView video_view;    private static final String TAG = VideoActivity.class.getSimpleName();    private static final String CLIENT_ID = "hgjHh11TeYg649dN5zT1";    private final int NONE = 0, DESTROY = 1, PLAY = 2, STOP = 3, NEXT = 4, PREV = 5, RESET = 6;    private final String VIDEO = "VIDEO",  NUMBER = "NUMBER", REALM_NAME = "CLearn.db";    private final String video = VIDEO.toLowerCase(), finish = "finish", save = "save";    private RecognitionHandler handler;    private NaverRecognizer naverRecognizer;    private AudioWriterPCM writer;    private VrVideoView.Options options;    private Context context;    private MediaPlayer mediaPlayer;    private Thread pThread;    private Realm realm;    private User user;    private String result, p_token;    private int v_num, event, number;    private boolean isPaused, isEvent, isFinish;    private long v_ctime, loadTime;    // 음성 인식 이벤트 과정    public void handleMessage(Message msg) {        switch (msg.what) {            case R.id.clientReady:                writer = new AudioWriterPCM(                        Environment.getExternalStorageDirectory().getAbsolutePath() + "/NaverSpeechTest");                writer.open("Test");                break;            case R.id.audioRecording:                writer.write((short[]) msg.obj);                break;            case R.id.finalResult:                SpeechRecognitionResult speechRecognitionResult = (SpeechRecognitionResult) msg.obj;                List<String> results = speechRecognitionResult.getResults();                for (String result : results) {                    // 음성 인식 이벤트 처리                    event = NONE;                    if (result.contains("종료")) {                        videoDestroy();                        event = DESTROY;                    } else if (result.contains("재생")) {                        isPaused = true;                        video_view.playVideo();                        event = PLAY;                    } else if (result.contains("정지")) {                        isPaused = false;                        video_view.pauseVideo();                        event = STOP;                    } else if (result.contains("앞으로")) {                        video_view.seekTo(v_ctime += 20000);                        event = NEXT;                    } else if (result.contains("뒤로")) {                        video_view.seekTo(v_ctime -= 20000);                        event = PREV;                    } else if (result.contains("처음으로")) {                        video_view.seekTo(v_ctime = 0);                        event = RESET;                    }                    if (event != NONE) {                        event = NONE;                        isEvent = true;                        break;                    }                }                if (!isEvent) {                    mediaPlayerInit(R.raw.re);                } else {                    isEvent = false;                }            case R.id.recognitionError:                if (writer != null) {                    writer.close();                }                break;            case R.id.clientInactive:                if (writer != null) {                    writer.close();                }                break;        }    }    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_video);        ButterKnife.bind(this);        context = this;        handler = new RecognitionHandler(this);        naverRecognizer = new NaverRecognizer(context, handler, CLIENT_ID);        p_token = getIntent().getStringExtra(Constant.P_TOKEN);        v_num = getIntent().getIntExtra(Constant.V_NUM, -1);        number = getSharedPreferences(VIDEO, MODE_PRIVATE).getInt(NUMBER, 0);        options = new VrVideoView.Options();        options.inputFormat = VrVideoView.Options.FORMAT_DEFAULT;        options.inputType = VrVideoView.Options.TYPE_MONO;        // 동영상 시작 시 풀 스크린 모드로 진행        video_view.setDisplayMode(VrVideoView.DisplayMode.FULLSCREEN_STEREO);        video_view.fullScreenDialog.setCancelable(false);        video_view.fullScreenDialog.setOnKeyListener((dialogInterface, i, keyEvent) -> {            if (keyEvent.getAction() == KeyEvent.ACTION_UP && !naverRecognizer.getSpeechRecognizer().isRunning()) {                // 뒤로가기 버튼이 터치 되었을 경우(컨트롤러 포함) 음성 인식 이벤트를 2초간 받음                naverRecognizer.recognize();                mediaPlayerInit(R.raw.start);                new Handler() {                    @Override                    public void handleMessage(Message msg) {                        naverRecognizer.getSpeechRecognizer().stop();                    }                }.sendEmptyMessageDelayed(0, 2000);            }            return false;        });        // PostVideo 인터페이스를 사용해 이전 로그인 액티비티에서 전달받은 값        // v_num과 p_token을 서버에 request 이후 response 받은 여러 정보들을 사용        RestInterface.getRestClient()                .create(RestInterface.PostVideo.class)                .video(video, v_num, p_token)                .subscribe(new Subscriber<Member>() {                    @Override                    public void onCompleted() {                    }                    @Override                    public void onError(Throwable e) {                        Log.e(TAG, String.valueOf(e));                    }                    @Override                    public void onNext(Member member) {                        Realm.init(context);                        RealmConfiguration config = new RealmConfiguration.Builder()                                .name(REALM_NAME)                                .schemaVersion(1)                                .build();                        realm = Realm.getInstance(config);                        realm.beginTransaction();                        user = realm.createObject(User.class, number);                        user.setP_token(p_token);                        user.setV_num(v_num);                        user.setStart_time(new SimpleDateFormat("yyyy-MM-dd:HH-mm-ss").format(new Date()));                        v_ctime = member.getV_ctime();                        Observable.just(member.getCt_file())                                .map(text -> Uri.parse(RestInterface.BASE + RestInterface.RESOURCES + member.getCt_file()))                                .subscribe(uri -> {                                    try {                                        video_view.loadVideo(uri, options);                                    } catch (IOException e) {                                        Log.e(TAG, String.valueOf(e));                                    }                                });                        video_view.seekTo(0);                        //video_view.seekTo(repo.getV_ctime());                        // 미디어 플레이어 혹은 비디오 플레이어가 종료되면 실행되는 인터페이스인                        // OnCompletionListener가 VrVideoView에 없는 관계로 직접 구현함                        // Thread를 돌려서 해당 동영상이 종료되면(총 재생 시간보다 현재 재생 시간이 많거나 같을 경우)                        // PostFinish 인터페이스를 사용해 이전 로그인 액티비티에서 전달받은 값 v_num을 서버에 request                        // 이후 해당 v_num의 v_finish의 값을 N에서 Y로 update                        loadTime = System.currentTimeMillis();                        Runnable runnable = () -> {                            while (!pThread.isInterrupted()) {                                v_ctime = video_view.getCurrentPosition();                                if (v_ctime >= video_view.getDuration() && loadTime + 2000 <= System.currentTimeMillis() && !isFinish) {                                    video_view.seekTo(0);//                                              isFinish = true;//                                    RestInterface.getRestClient()//                                            .create(RestInterface.PostFinish.class)//                                            .finish(finish, v_num)//                                            .subscribe(new Subscriber<Void>() {//                                                @Override//                                                public void onCompleted() {//                                                }////                                                @Override//                                                public void onError(Throwable e) {//                                                    Log.e(TAG, String.valueOf(e));//                                                }////                                                @Override//                                                public void onNext(Void aVoid) {//                                                }//                                            });                                }                            }                        };                        pThread = new Thread(runnable);                        pThread.start();                    }                });    }    @Override    public void onPause() {        super.onPause();        naverRecognizer.getSpeechRecognizer().release();        video_view.pauseRendering();        v_ctime = video_view.getCurrentPosition();    }    @Override    public void onResume() {        super.onResume();        getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION ^ View.SYSTEM_UI_FLAG_FULLSCREEN ^ View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);        naverRecognizer.getSpeechRecognizer().initialize();        video_view.resumeRendering();        video_view.seekTo(v_ctime);        if (isPaused) {            video_view.pauseVideo();        } else {            video_view.playVideo();        }    }    // Realm DB에 데이터를 저장하고    // OnCompletionListener 역할을 대신 수행하는 Thread를 종료하며,    // 현재 재생 시간을 PostSave 인터페이스를 사용해 이전 로그인 액티비티에서 전달받은 값    // v_num과 현재 재생 시간인 v_ctime, Realm DB의 값 result를 서버에 request    // 이후 해당 v_num에 v_ctime을 update 후 어플을 종료    public void videoDestroy() {        getSharedPreferences(VIDEO, MODE_PRIVATE).edit().putInt(NUMBER, number + 1).apply();        user.setEnd_time(new SimpleDateFormat("yyyy-MM-dd:HH-mm-ss").format(new Date()));        realm.insert(user);        realm.commitTransaction();        result = realm.where(User.class).findAll().toString();        mediaPlayerInit(R.raw.destroy);        pThread.interrupt();        RestInterface.getRestClient()                .create(RestInterface.PostSave.class)                .save(save, v_num, v_ctime, result)                .subscribe(new Subscriber<Void>() {                    @Override                    public void onCompleted() {                    }                    @Override                    public void onError(Throwable e) {                        Log.e(TAG, String.valueOf(e));                    }                    @Override                    public void onNext(Void aVoid) {                        video_view.fullScreenDialog.dismiss();                        video_view.pauseRendering();                        video_view.shutdown();                        finish();                    }                });    }    public void mediaPlayerInit(int resId) {        if (mediaPlayer != null) {            mediaPlayer.stop();            mediaPlayer.release();        }        mediaPlayer = MediaPlayer.create(context, resId);        mediaPlayer.setOnPreparedListener(mp -> mp.start());    }    private static class RecognitionHandler extends Handler {        private final WeakReference<VideoActivity> mActivity;        RecognitionHandler(VideoActivity activity) {            mActivity = new WeakReference<>(activity);        }        @Override        public void handleMessage(Message msg) {            VideoActivity activity = mActivity.get();            if (activity != null) {                activity.handleMessage(msg);            }        }    }}